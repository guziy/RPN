MM_PER_CM = 10

from collections import OrderedDict
from pathlib import Path
from matplotlib import cm
from matplotlib.gridspec import GridSpec
from matplotlib.ticker import MaxNLocator
from crcm5 import infovar
from crcm5.analyse_hdf.run_config import RunConfig
from cru.temperature import CRUDataManager
from util import plot_utils

from crcm5.analyse_hdf import do_analysis_using_pytables as analysis
from util.geo.basemap_info import BasemapInfo
from util.seasons_info import DEFAULT_SEASON_TO_MONTHS
import numpy as np
from crcm5.analyse_hdf.climate_change import plot_performance_err_with_cru

__author__ = 'huziy'

# Folder where images generated by the script will go
img_folder = Path("cc_paper/performane_error_with_udel")

import matplotlib.pyplot as plt


def aggregate_array(in_arr, nagg_x=2, nagg_y=2):
    """


    :type in_arr: numpy.ndarray
    :type nagg_y: int
    """
    from skimage.util import view_as_blocks

    return view_as_blocks(in_arr, (nagg_x, nagg_y)).mean(axis=2).mean(axis=2)


def plot_seasonal_mean_biases(season_to_error_field=None, varname="", basemap_info=None):
    assert isinstance(basemap_info, BasemapInfo)

    cmap = cm.get_cmap("RdBu_r", 20)

    # Set to False if you want the limits to be recalculated from data
    manual_limits = True

    minval = min([np.percentile(field[~field.mask], 95) for s, field in season_to_error_field.items()])
    maxval = max([np.percentile(field[~field.mask], 95) for s, field in season_to_error_field.items()])

    if manual_limits:
        if varname == "PR":
            minval, maxval = -3, 3
        if varname == "TT":
            minval, maxval = -7, 7

    d = max(abs(minval), abs(maxval))
    clevs = MaxNLocator(nbins=cmap.N, symmetric=True).tick_values(-d, d)

    fig_path = img_folder.joinpath("{}.png".format(varname))
    fig = plt.figure()

    nrows = 2
    ncols = 2
    gs = GridSpec(nrows, ncols=ncols + 1, width_ratios=[1, 1, 0.05])

    xx, yy = basemap_info.get_proj_xy()

    cs = None
    for i, season in enumerate(season_to_error_field):
        row = i // ncols
        col = i % ncols

        ax = fig.add_subplot(gs[row, col])
        cs = basemap_info.basemap.contourf(xx, yy, season_to_error_field[season], ax=ax, cmap=cmap, levels=clevs,
                                           extend="both")
        basemap_info.basemap.drawcoastlines()
        ax.set_title(season)
        # basemap_info.basemap.colorbar(cs)

    cax = fig.add_subplot(gs[:, -1])
    cax.set_title(infovar.get_units(var_name=varname))
    plt.colorbar(cs, cax=cax)

    with fig_path.open("wb") as figfile:
        fig.savefig(figfile, format="png", bbox_inches="tight")

    plt.close(fig)


def compare_vars(vname_model="TT", vname_obs="tmp", r_config=None,
                 season_to_months=None,
                 obs_path=None, nx_agg=5, ny_agg=5, bmp_info_agg=None, axes_list=None):
    seasonal_clim_fields_model = analysis.get_seasonal_climatology_for_runconfig(run_config=r_config,
                                                                                 varname=vname_model, level=0,
                                                                                 season_to_months=season_to_months)

    season_to_clim_fields_model_agg = OrderedDict()
    for season, field in seasonal_clim_fields_model.items():
        print(field.shape)
        season_to_clim_fields_model_agg[season] = aggregate_array(field, nagg_x=nx_agg, nagg_y=ny_agg)
        if vname_model == "PR":
            season_to_clim_fields_model_agg[season] *= 1.0e3 * 24 * 3600

    if obs_path is None:
        cru = CRUDataManager(var_name=vname_obs)
    else:
        cru = CRUDataManager(var_name=vname_obs, path=obs_path)

    seasonal_clim_fields_obs = cru.get_seasonal_means(season_name_to_months=season_to_months,
                                                      start_year=r_config.start_year,
                                                      end_year=r_config.end_year)

    seasonal_clim_fields_obs_interp = OrderedDict()
    for season, cru_field in seasonal_clim_fields_obs.items():
        seasonal_clim_fields_obs_interp[season] = cru.interpolate_data_to(cru_field,
                                                                          lons2d=bmp_info_agg.lons,
                                                                          lats2d=bmp_info_agg.lats, nneighbours=1)

        assert hasattr(seasonal_clim_fields_obs_interp[season], "mask")

    season_to_err = OrderedDict()
    for season in seasonal_clim_fields_obs_interp:
        if vname_model == "PR":
            # * 10, because in the UDEL dataset, precipitation is in cm
            season_to_err[season] = season_to_clim_fields_model_agg[season] - \
                                    seasonal_clim_fields_obs_interp[season] * MM_PER_CM
        else:
            season_to_err[season] = season_to_clim_fields_model_agg[season] - seasonal_clim_fields_obs_interp[season]

    plot_performance_err_with_cru.plot_seasonal_mean_biases(season_to_error_field=season_to_err, varname=vname_model,
                                                            basemap_info=bmp_info_agg,
                                                            axes_list=axes_list)


def main():
    plot_utils.apply_plot_params(font_size=12, width_pt=None, width_cm=25, height_cm=25)

    season_to_months = DEFAULT_SEASON_TO_MONTHS

    r_config = RunConfig(
        data_path="/RESCUE/skynet3_rech1/huziy/hdf_store/quebec_0.1_crcm5-hcd-rl.hdf5",
        start_year=1980, end_year=2009, label="CRCM5-L"
    )

    # Number of points for aggregation
    nx_agg = 5
    ny_agg = 5

    bmp_info = analysis.get_basemap_info_from_hdf(file_path=r_config.data_path)

    bmp_info_agg = bmp_info.get_aggregated(nagg_x=nx_agg, nagg_y=ny_agg)


    # Validate temperature and precip
    model_vars = ["TT", "PR"]
    obs_vars = ["air", "precip"]
    obs_paths = [
        "/RECH/data/Validation/Willmott_Matsuura/NetCDF/air.mon.mean.v301.nc",
        "/RECH/data/Validation/Willmott_Matsuura/NetCDF/precip.mon.total.v301.nc"
    ]

    plot_all_vars_in_one_fig = True

    fig = None
    gs = None
    row_axes = None
    ncols = None
    if plot_all_vars_in_one_fig:
        plot_utils.apply_plot_params(font_size=12, width_pt=None, width_cm=25, height_cm=12)
        fig = plt.figure()
        ncols = len(season_to_months) + 1
        gs = GridSpec(len(model_vars), ncols, width_ratios=(ncols - 1) * [1., ] + [0.05, ])
    else:
        plot_utils.apply_plot_params(font_size=12, width_pt=None, width_cm=25, height_cm=25)

    row = 0
    for mname, oname, opath in zip(model_vars, obs_vars, obs_paths):

        if plot_all_vars_in_one_fig:
            row_axes = [fig.add_subplot(gs[row, col]) for col in range(ncols)]

        compare_vars(vname_model=mname, vname_obs=oname, r_config=r_config,
                     season_to_months=season_to_months,
                     nx_agg=nx_agg, ny_agg=ny_agg, bmp_info_agg=bmp_info_agg,
                     obs_path=opath, axes_list=row_axes)

        row += 1

    # Save the figure if necessary
    if plot_all_vars_in_one_fig:
        fig_path = img_folder.joinpath("{}.png".format("_".join(model_vars)))
        with fig_path.open("wb") as figfile:
            fig.savefig(figfile, format="png", bbox_inches="tight")

        plt.close(fig)


def main_wrapper():
    print("Comparing with UDEL ...")
    import application_properties

    application_properties.set_current_directory()

    if not img_folder.is_dir():
        img_folder.mkdir(parents=True)

    #
    main()


if __name__ == '__main__':
    main_wrapper()