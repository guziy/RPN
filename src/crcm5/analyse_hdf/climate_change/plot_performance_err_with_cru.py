from collections import OrderedDict
from pathlib import Path

import numpy as np
from matplotlib import cm
from matplotlib.colors import BoundaryNorm
from matplotlib.gridspec import GridSpec
from matplotlib.ticker import MaxNLocator
from mpl_toolkits.basemap import maskoceans

from crcm5 import infovar
from crcm5.analyse_hdf import do_analysis_using_pytables as analysis
from crcm5.analyse_hdf.run_config import RunConfig
from cru.temperature import CRUDataManager
from data.swe import SweDataManager
from util import plot_utils
from util.array_utils import aggregate_array
from util.geo import quebec_info
from util.geo.basemap_info import BasemapInfo
from util.geo.mask_from_shp import get_mask
from util.seasons_info import DEFAULT_SEASON_TO_MONTHS

__author__ = 'huziy'

# Folder where images generated by the script will go
img_folder = Path("cc_paper/performane_error_with_cru")

BASIN_BOUNDARIES_SHP = quebec_info.BASIN_BOUNDARIES_DERIVED_10km

import matplotlib.pyplot as plt


def get_seasonal_clim_obs_data(rconfig=None, vname="TT", bmp_info=None, season_to_months=None, obs_path=None,
                               nx_agg=None, ny_agg=None):
    # Number of points for aggregation
    """
    return aggregated BasemapInfo object corresponding to the CRU resolution

    :param rconfig:
    :param vname:
    :param bmp_info: BasemapInfo object for the model field (will be upscaled to the CRU resolution)
    :param season_to_months:
    """

    if bmp_info is None:
        bmp_info = analysis.get_basemap_info_from_hdf(file_path=rconfig.data_path)

    if nx_agg is not None:
        bmp_info_agg = bmp_info.get_aggregated(nagg_x=nx_agg, nagg_y=ny_agg)
    else:
        bmp_info_agg = bmp_info

    # Validate temperature and precip
    model_vars = ["TT", "PR"]
    obs_vars = ["tmp", "pre"]

    obs_paths = [
        "/HOME/data/Validation/CRU_TS_3.1/Original_files_gzipped/cru_ts_3_10.1901.2009.tmp.dat.nc",
        "/HOME/data/Validation/CRU_TS_3.1/Original_files_gzipped/cru_ts_3_10.1901.2009.pre.dat.nc"
    ]

    model_var_to_obs_var = dict(zip(model_vars, obs_vars))
    model_var_to_obs_path = dict(zip(model_vars, obs_paths))

    if obs_path is None:
        obs_path = model_var_to_obs_path[vname]

    cru = CRUDataManager(var_name=model_var_to_obs_var[vname], path=obs_path)

    seasonal_clim_fields_obs = cru.get_seasonal_means(season_name_to_months=season_to_months,
                                                      start_year=rconfig.start_year,
                                                      end_year=rconfig.end_year)

    seasonal_clim_fields_obs_interp = OrderedDict()
    for season, cru_field in seasonal_clim_fields_obs.items():
        seasonal_clim_fields_obs_interp[season] = cru.interpolate_data_to(cru_field,
                                                                          lons2d=bmp_info_agg.lons,
                                                                          lats2d=bmp_info_agg.lats, nneighbours=1)

        # assert hasattr(seasonal_clim_fields_obs_interp[season], "mask")

    return bmp_info_agg, seasonal_clim_fields_obs_interp


def plot_seasonal_mean_biases(season_to_error_field=None, varname="", basemap_info=None,
                              axes_list=None):
    assert isinstance(basemap_info, BasemapInfo)

    # Set to False if you want the limits to be recalculated from data
    manual_limits = True

    d = max([np.percentile(np.abs(field[~field.mask]), 95) for s, field in season_to_error_field.items()])

    if manual_limits and varname in ["PR", "TT", "I5"]:
        clevs = np.arange(-d, 1.1 * d, 0.1 * d)

        if varname == "PR":
            clevs = np.arange(-3, 3.5, 0.5)
        if varname == "TT":
            clevs = np.arange(-7, 8, 1)
        if varname == "I5":
            clevs = np.arange(-100, 110, 10)

    else:
        clevs = MaxNLocator(nbins=10, symmetric=True).tick_values(-d, d)
    cmap = cm.get_cmap("RdBu_r", len(clevs) - 1)

    fig = None
    fig_path = None
    if axes_list is None:
        fig_path = img_folder.joinpath("{}.png".format(varname))
        fig = plt.figure()

    nrows = 2
    ncols = 2
    gs = GridSpec(nrows, ncols=ncols + 1, width_ratios=[1, 1, 0.05])

    xx, yy = basemap_info.get_proj_xy()

    cs = None
    for i, season in enumerate(season_to_error_field):
        row = i // ncols
        col = i % ncols

        if axes_list is None:
            ax = fig.add_subplot(gs[row, col])
        else:
            ax = axes_list[i]

        basemap_info.draw_map_background(ax)

        cs = basemap_info.basemap.contourf(xx, yy, season_to_error_field[season][:], ax=ax, cmap=cmap, levels=clevs,
                                           extend="both")
        basemap_info.basemap.drawcoastlines(ax=ax, linewidth=0.3)
        ax.set_title(season)
        if i == 0:
            ax.set_ylabel(infovar.get_long_display_label_for_var(varname=varname))
        # basemap_info.basemap.colorbar(cs)

        if basemap_info.should_draw_basin_boundaries:
            basemap_info.basemap.readshapefile(BASIN_BOUNDARIES_SHP[:-4], "basin", ax=ax)

        # Hide snow plots for summer
        if varname in ["I5"] and season.lower() in ["summer"]:
            ax.set_visible(False)

        # Plot a colorbar for each subplot if required.
        if hasattr(basemap_info, "draw_colorbar_for_each_subplot"):
            if basemap_info.draw_colorbar_for_each_subplot:
                cb = basemap_info.basemap.colorbar(cs, ax=ax)
                cb.ax.set_title(infovar.get_units(var_name=varname))

    cax = fig.add_subplot(gs[:, -1]) if axes_list is None else axes_list[-1]

    # Add the colorbar if there are additional axes supplied for it
    if len(axes_list) > len(season_to_error_field):
        cax.set_title(infovar.get_units(var_name=varname))
        plt.colorbar(cs, cax=cax)

    if axes_list is None:
        with fig_path.open("wb") as figfile:
            fig.savefig(figfile, format="png", bbox_inches="tight")

        plt.close(fig)

    return cs


def compare_vars(vname_model="TT", vname_obs="tmp", r_config=None,
                 season_to_months=None,
                 obs_path=None, nx_agg_model=5, ny_agg_model=5, bmp_info_agg=None,
                 diff_axes_list=None, obs_axes_list=None,
                 model_axes_list=None, bmp_info_model=None,
                 mask_shape_file=None, nx_agg_obs=1, ny_agg_obs=1):
    """

    if obs_axes_list is not None, plot observation data in those

    :param mask_shape_file:
    :param bmp_info_model: basemap info native to the model
    :param model_axes_list: Axes to plot model outputs
    :param vname_model:
    :param vname_obs:
    :param r_config:
    :param season_to_months:
    :param obs_path:
    :param nx_agg_model:
    :param ny_agg_model:
    :param bmp_info_agg:
    :param diff_axes_list: if it is None the plots for each variable is done in separate figures
    """

    if vname_obs is None:
        vname_model_to_vname_obs = {"TT": "tmp", "PR": "pre"}
        vname_obs = vname_model_to_vname_obs[vname_model]

    seasonal_clim_fields_model = analysis.get_seasonal_climatology_for_runconfig(run_config=r_config,
                                                                                 varname=vname_model, level=0,
                                                                                 season_to_months=season_to_months)


    season_to_clim_fields_model_agg = OrderedDict()
    for season, field in seasonal_clim_fields_model.items():
        print(field.shape)
        season_to_clim_fields_model_agg[season] = aggregate_array(field, nagg_x=nx_agg_model, nagg_y=ny_agg_model)
        if vname_model == "PR":
            season_to_clim_fields_model_agg[season] *= 1.0e3 * 24 * 3600

    if vname_obs in ["SWE", ]:
        obs_manager = SweDataManager(path=obs_path, var_name=vname_obs)
    elif obs_path is None:
        obs_manager = CRUDataManager(var_name=vname_obs)
    else:
        obs_manager = CRUDataManager(var_name=vname_obs, path=obs_path)

    seasonal_clim_fields_obs = obs_manager.get_seasonal_means(season_name_to_months=season_to_months,
                                                              start_year=r_config.start_year,
                                                              end_year=r_config.end_year)

    seasonal_clim_fields_obs_interp = OrderedDict()
    # Derive the mask from a shapefile if provided
    if mask_shape_file is not None:
        the_mask = get_mask(bmp_info_agg.lons, bmp_info_agg.lats, shp_path=mask_shape_file)
    else:
        the_mask = np.zeros_like(bmp_info_agg.lons)

    for season, obs_field in seasonal_clim_fields_obs.items():
        obs_field = obs_manager.interpolate_data_to(obs_field,
                                                    lons2d=bmp_info_agg.lons,
                                                    lats2d=bmp_info_agg.lats,
                                                    nneighbours=nx_agg_obs * ny_agg_obs)

        obs_field = np.ma.masked_where(the_mask > 0.5, obs_field)

        seasonal_clim_fields_obs_interp[season] = obs_field

        # assert hasattr(seasonal_clim_fields_obs_interp[season], "mask")

    season_to_err = OrderedDict()
    print("-------------var: {} (PE with CRU)---------------------".format(vname_model))
    for season in seasonal_clim_fields_obs_interp:
        seasonal_clim_fields_obs_interp[season] = np.ma.masked_where(np.isnan(seasonal_clim_fields_obs_interp[season]),
                                                                     seasonal_clim_fields_obs_interp[season])
        season_to_err[season] = season_to_clim_fields_model_agg[season] - seasonal_clim_fields_obs_interp[season]

        if vname_model in ["I5"]:
            lons = bmp_info_agg.lons.copy()
            lons[lons > 180] -= 360
            season_to_err[season] = maskoceans(lons, bmp_info_agg.lats, season_to_err[season])

        good_vals = season_to_err[season]
        good_vals = good_vals[~good_vals.mask]
        
        print("{}: min={}; max={}; avg={}".format(season,
                                                  good_vals.min(),
                                                  good_vals.max(),
                                                  good_vals.mean()))

        print("---------percetages --- CRU ---")
        print("{}: {} \%".format(season, good_vals.mean() / seasonal_clim_fields_obs_interp[season][~season_to_err[season].mask].mean() * 100))





    cs = plot_seasonal_mean_biases(season_to_error_field=season_to_err,
                                   varname=vname_model,
                                   basemap_info=bmp_info_agg,
                                   axes_list=diff_axes_list)

    if obs_axes_list is not None and vname_model in ["I5"]:

        clevs = [0, 50, 60, 70, 80, 90, 100, 150, 200, 250, 300, 350, 400, 500]
        cs_obs = None
        xx, yy = bmp_info_agg.get_proj_xy()
        lons = bmp_info_agg.lons.copy()
        lons[lons > 180] -= 360


        lons_model = None
        xx_model, yy_model = None, None
        cs_mod = None

        norm = BoundaryNorm(clevs, 256)
        for col, (season, obs_field) in enumerate(seasonal_clim_fields_obs_interp.items()):

            # Obsrved fields
            ax = obs_axes_list[col]

            if bmp_info_agg.should_draw_basin_boundaries:
                bmp_info_agg.basemap.readshapefile(BASIN_BOUNDARIES_SHP[:-4], "basin", ax=ax)

            to_plot = maskoceans(lons, bmp_info_agg.lats, obs_field)
            cs_obs = bmp_info_agg.basemap.contourf(xx, yy, to_plot, levels=clevs, ax=ax, norm=norm, extend="max")

            bmp_info_agg.basemap.drawcoastlines(ax=ax, linewidth=0.3)

            ax.set_title(season)

            # Model outputs
            if model_axes_list is not None:
                ax = model_axes_list[col]

                if bmp_info_agg.should_draw_basin_boundaries:
                    bmp_info_agg.basemap.readshapefile(BASIN_BOUNDARIES_SHP[:-4], "basin", ax=ax)

                if lons_model is None:
                    lons_model = bmp_info_model.lons.copy()
                    lons_model[lons_model > 180] -= 360
                    xx_model, yy_model = bmp_info_model.basemap(lons_model, bmp_info_model.lats)

                model_field = seasonal_clim_fields_model[season]

                to_plot = maskoceans(lons_model, bmp_info_model.lats, model_field)
                cs_mod = bmp_info_agg.basemap.contourf(xx_model, yy_model, to_plot, levels=cs_obs.levels, ax=ax,
                                                       norm=cs_obs.norm, cmap=cs_obs.cmap, extend="max")

                bmp_info_agg.basemap.drawcoastlines(ax=ax, linewidth=0.3)


        plt.colorbar(cs_obs, cax=obs_axes_list[-1])


    return cs


def main():
    season_to_months = DEFAULT_SEASON_TO_MONTHS

    r_config = RunConfig(
        data_path="/RESCUE/skynet3_rech1/huziy/hdf_store/quebec_0.1_crcm5-hcd-rl.hdf5",
        start_year=1980, end_year=2009, label="CRCM5-L"
    )

    # Number of points for aggregation
    nx_agg = 5
    ny_agg = 5

    bmp_info = analysis.get_basemap_info_from_hdf(file_path=r_config.data_path)

    bmp_info_agg = bmp_info.get_aggregated(nagg_x=nx_agg, nagg_y=ny_agg)

    # Validate temperature and precip
    model_vars = ["TT", "PR"]
    obs_vars = ["tmp", "pre"]
    obs_paths = [
        "/HOME/data/Validation/CRU_TS_3.1/Original_files_gzipped/cru_ts_3_10.1901.2009.tmp.dat.nc",
        "/HOME/data/Validation/CRU_TS_3.1/Original_files_gzipped/cru_ts_3_10.1901.2009.pre.dat.nc"
    ]

    plot_all_vars_in_one_fig = True

    fig = None
    gs = None
    row_axes = None
    ncols = None
    if plot_all_vars_in_one_fig:
        plot_utils.apply_plot_params(font_size=12, width_pt=None, width_cm=25, height_cm=12)
        fig = plt.figure()
        ncols = len(season_to_months) + 1
        gs = GridSpec(len(model_vars), ncols, width_ratios=(ncols - 1) * [1., ] + [0.05, ])
    else:
        plot_utils.apply_plot_params(font_size=12, width_pt=None, width_cm=25, height_cm=25)

    row = 0
    for mname, oname, opath in zip(model_vars, obs_vars, obs_paths):

        if plot_all_vars_in_one_fig:
            row_axes = [fig.add_subplot(gs[row, col]) for col in range(ncols)]

        compare_vars(vname_model=mname, vname_obs=oname, r_config=r_config,
                     season_to_months=season_to_months,
                     nx_agg_model=nx_agg, ny_agg_model=ny_agg, bmp_info_agg=bmp_info_agg,
                     obs_path=opath, diff_axes_list=row_axes)

        row += 1

    # Save the figure if necessary
    if plot_all_vars_in_one_fig:
        fig_path = img_folder.joinpath("{}.png".format("_".join(model_vars)))
        with fig_path.open("wb") as figfile:
            fig.savefig(figfile, format="png", bbox_inches="tight")

        plt.close(fig)


def main_wrapper():
    print("Comparing with CRU ...")
    import application_properties

    application_properties.set_current_directory()

    if not img_folder.is_dir():
        img_folder.mkdir(parents=True)

    #
    main()


if __name__ == '__main__':
    main_wrapper()
